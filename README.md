# Demo: Train a small neural network in a Docker container

Docker enables portability and reproducibility of a codebase. This repository serves as an example for training neural networks in Docker containers, as well as running GUI applications.

Notes:

- Instead of developing the ultimate neural network. the focus of this repository is to show how one can train a neural network in Docker containers. In other words, contents in `train.py` and `utils.py` is out of scope.

- Although this repository only uses Python, one can extend the idea to arbitrary languages/tools.

- In addition to [Docker Hub](https://hub.docker.com/), [NGC](https://catalog.ngc.nvidia.com/containers) is also a popular place (i.e. registry) for pulling prebuild images. One can also host private registries using [Red Hat Quay](https://quay.io/) or [Google Cloud Container Registry](https://cloud.google.com/container-registry).

## Prerequisites

### Hardware

- `amd64` CPU(s)
- NVIDIA GPU(s) with Architecture >= Kepler (or compute capability 3.0)

### Software

- Ubuntu 18.04, 20.04, or 22.04
- NVIDIA driver >= 450
- [NVIDIA Container Toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker)
- git


## Instructions

1. Clone the repository

    ```bash
    $ git clone https://github.com/tn00364361/demo-cnn-docker.git
    $ cd demo-cnn-docker
    ```

2. Build the Docker image:

    ```bash
    $ ./docker/build.sh
    ```

    This step can take a couple of minutes, depending on your internet connection. Once it finishes, run `docker image ls` to verify the existence of the image.

3. Launch a container

    ```bash
    $ ./docker/run.sh       # use all GPUs (default)
    $ ./docker/run.sh 0     # use GPU0 only
    $ ./docker/run.sh 2,3   # use GPU2 and GPU3
    ```

    The username and hostname should become yellow and the working directory should be `/my_workspace`, indicating that you are now in a container. Run `ll` to verify that you can see the host files.

## Details


- Differences between images and containers

    An image can be seen as a snapshot of an environment. It encapsulates all dependencies, including software packages and environmental variables, in a static state. On can pull images from [Docker Hub](https://hub.docker.com/). For example:

    ```bash
    $ docker pull ubuntu:20.04
    ```

    By contrast, a container is (usually) interactive and can be launched given the name of an image. For example:

    ```bash
    $ docker run -it --rm ubuntu:20.04
    ```

    A more sophisticated example can be found in the [run script](docker/run.sh) which will be explained later.

- `docker/rootfs`

    This is part of the root file system to be mounted to a container by the [run script](docker/run.sh).

    - `docker/rootfs/etc`

        This directory contains two files, `passwd` and `group`, generated by the [run script](docker/run.sh), to be mounted to a container.

        Although one can usually mount the host's `/etc/passwd` and `/etc/group` to a container to achieve the same purpose, it may not always work especially when the user is managed by a centralized authentication server such as [FreeIPA](https://www.freeipa.org/page/Main_Page), OpenLDAP, or Active Directory.

        An alternative is to create a user with the current UID and GID in the Dockerfile. However, this method makes the image non-portable (thus cannot be deployed using private registry servers) since the UID and GID might vary on different machines/accounts.

    - `docker/rootfs/home/user`

        This is the home directory to be mounted in the container. Mounting it allows the user in the container to keep files like Bash/Python history and some common configuration files.

- [`docker/Dockerfile`](docker/Dockerfile)

    This file containes instructions to build the desired image. Starting from a base image, environmental variables are set, and packages are installed.

    It is a good pratice to explicitly specify the software versions. For example, when providing a [`requirements.txt`](requirements.txt) for PIP, one should prefer `==` or `>=X,<Y` over `>=` or no versioning at all.

    Another example is when cloning a thirdparty repository as a dependency, one should always checkout to a particular tag or commit.

- [`docker/build.sh`](docker/build.sh)

    This script builds the image with a predefined tag (i.e. name of the image). See the [official documentation](https://docs.docker.com/engine/reference/commandline/build/) for more details.

- [`docker/run.sh`](docker/run.sh)

    This script launchs a container from the built image. In short, this script handles GUI- and user-related stuff.

    - GUI

        ```bash
        #!/usr/bin/env bash
        ...
        xhost +local:

        docker run -it --rm \
            ...
            -e DISPLAY \
            -e QT_X11_NO_MITSHM=1 \
            -e XDG_RUNTIME_DIR=/run/user/$(id -u)
            -v /run/user/$(id -u):/run/user/$(id -u)
            -v /tmp/.X11-unix:/tmp/.X11-unix:rw
            ...
            demo-cnn

        xhost -local:
        ```

    - User & group passthrough

        ```bash
        #!/usr/bin/env bash

        ROOTFS=$(pwd)/docker/rootfs
        [ ! -f $ROOTFS/etc/passwd ] && echo $(getent passwd $(id -un)) > $ROOTFS/etc/passwd
        [ ! -f $ROOTFS/etc/group ] && echo $(getent group $(id -un)) > $ROOTFS/etc/group
        ...
        docker run -it --rm \
            ...
            -e HOME \
            -u $(id -u):$(id -g) \
            -v $ROOTFS/etc/passwd:/etc/passwd:ro \
            -v $ROOTFS/etc/group:/etc/group:ro \
            -v $ROOTFS/home/user:$HOME \
            ...
            demo-cnn
        ...
        ```
