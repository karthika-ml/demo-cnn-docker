# Demo: Train a small neural network in a Docker container

Docker enables portability and reproducibility of a codebase. This repository serves as an example for training neural networks in Docker containers, as well as running GUI applications.

Notes:

- Instead of developing the ultimate neural network, the focus of this repository is to show how one can train a neural network in Docker containers. In other words, contents in `train.py` and `utils.py` are out of scope.

- Although this repository only uses Python, one can extend the idea to arbitrary languages/tools.

- In addition to [Docker Hub](https://hub.docker.com/), [NGC](https://catalog.ngc.nvidia.com/containers) is also a popular place (i.e. registry) for pulling prebuilt images. One can also host private registries using [Red Hat Quay](https://quay.io/) or [Google Cloud Container Registry](https://cloud.google.com/container-registry).

- Any feedback is welcome! Feel free to start a [discussion](https://github.com/tn00364361/demo-cnn-docker/discussions).

## Prerequisites

### Hardware

- `amd64` CPU(s)
- NVIDIA GPU(s) with Architecture >= Kepler (or compute capability 3.0)

### Software

- Ubuntu 18.04, 20.04, or 22.04
- NVIDIA driver >= 450
- [NVIDIA Container Toolkit](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/install-guide.html#docker)
- git


## Instructions

1. Clone the repository

    ```bash
    $ git clone https://github.com/tn00364361/demo-cnn-docker.git
    $ cd demo-cnn-docker
    ```

2. Build the Docker image:

    ```bash
    $ ./docker/build.sh
    ```

    This step can take a couple of minutes, depending on your internet connection. Once it finishes, run `docker image ls` to verify the existence of the image.

3. Launch a container

    ```bash
    $ ./docker/run.sh           # use GPU0 only (default)
    $ ./docker/run.sh -g all    # use all GPU(s)
    $ ./docker/run.sh -g 2,3    # use GPU2 and GPU3
    ```

    See [here](https://docs.nvidia.com/datacenter/cloud-native/container-toolkit/user-guide.html#gpu-enumeration) for valid values for GPU ID(s).

    The username and hostname should become yellow and the working directory should be `/my_workspace`, indicating that you are now in a container. Run `ll` to verify that you can see the host files.

    In addition, run `nvidia-smi` in the container to veirfy that the GPU is visible in the container.

## Details


- Differences between images and containers

    An image can be seen as a snapshot of an environment. It encapsulates all dependencies, including software packages and environmental variables, in a static state. On can pull prebuilt images from [Docker Hub](https://hub.docker.com/). For example:

    ```bash
    $ docker pull ubuntu:20.04
    ```

    By contrast, a container is (usually) interactive and can be launched given the name of an image. For example:

    ```bash
    $ docker run -it --rm ubuntu:20.04
    ```

    A more sophisticated example can be found in the [run script](docker/run.sh) which will be explained later.

- Running as the `root` user or using `sudo` in containers

    **TL;DR: Don't**.

    Once the image is built, one should launch containers using the `-u` flag, as shown in the [run script](docker/run.sh). This allows the written files to have the correct ownership, instead of to be owned by the `root` user.

    If you want to install packages or change system cofiguration files, do them in the Dockerfile.

- `docker/rootfs`

    This is part of the root file system to be mounted to a container by the [run script](docker/run.sh).

    - `docker/rootfs/etc`

        This directory contains two files, `passwd` and `group`, generated by the [run script](docker/run.sh), to be mounted to a container.

        Although one can usually mount the host's `/etc/passwd` and `/etc/group` to a container to achieve the same purpose, it may not always work especially when the user is managed by a centralized authentication server such as [FreeIPA](https://www.freeipa.org/page/Main_Page), OpenLDAP, or Active Directory.

        An alternative is to create a user with the current UID and GID in the Dockerfile. However, this method makes the image non-portable (thus cannot be deployed using private registry servers) since the UID and GID might vary on different machines/accounts.

    - `docker/rootfs/home/user`

        This is the home directory to be mounted to a container. Mounting it allows the user in the container to keep files like Bash/Python history and some common configuration files.

- [`docker/Dockerfile`](docker/Dockerfile)

    This file containes instructions to build the desired image. Starting from a base image, environmental variables are set, and packages are installed.

    When developing custom/new algorithms, one **almost always** wants to write their own Dockerfile instead of using a prebuilt image from Dockerh Hub. A typical pipeline may look like this:

    1. Figure out dependencies of the project.
    2. Write a [Dockerfile](docker/Dockerfile) with all dependencies.
    3. [Build](docker/build.sh) the image.
    4. [Launch](docker/run.sh) a container.
    5. Develop and test your algorithm in the container.
    6. If new dependency appears during development, go back to 1 and reiterate.

    In addition, it is a good pratice to explicitly specify the software versions. For example, when providing a [`requirements.txt`](requirements.txt) for PIP, one should prefer `==` or `>=X,<Y` over `>=` or no versioning at all.

    Another thing to pay attention to is that when cloning a thirdparty repository as a dependency, one should checkout to a particular tag or commit in the Dockerfile.

- [`docker/build.sh`](docker/build.sh)

    This script builds the image with a predefined tag (i.e. name of the image). See the [official documentation](https://docs.docker.com/engine/reference/commandline/build/) for more details.

- [`docker/run.sh`](docker/run.sh)

    This script launchs a container from the built image. In short, this script handles GUI- and user-related stuff, in addition to accessing GPU(s) for training neural networks.

    - GUI

        ```bash
        #!/usr/bin/env bash
        ...
        xhost +local:

        docker run -it --rm \
            ...
            -e DISPLAY \
            -e QT_X11_NO_MITSHM=1 \
            -e XDG_RUNTIME_DIR=/run/user/$(id -u)
            -v /run/user/$(id -u):/run/user/$(id -u)
            -v /tmp/.X11-unix:/tmp/.X11-unix:rw
            ...
            demo-cnn

        xhost -local:
        ```

    - User & group passthrough

        ```bash
        #!/usr/bin/env bash
        ...
        ROOTFS=$(pwd)/docker/rootfs
        [ ! -f $ROOTFS/etc/passwd ] && echo $(getent passwd $(id -un)) > $ROOTFS/etc/passwd
        [ ! -f $ROOTFS/etc/group ] && echo $(getent group $(id -un)) > $ROOTFS/etc/group
        ...
        docker run -it --rm \
            ...
            -e HOME \
            -u $(id -u):$(id -g) \
            -v $ROOTFS/etc/passwd:/etc/passwd:ro \
            -v $ROOTFS/etc/group:/etc/group:ro \
            -v $ROOTFS/home/user:$HOME \
            ...
            demo-cnn
        ...
        ```

    - GPU access

        ```bash
        #!/usr/bin/env bash
        ...
        [ -z $GPU ] && GPU=all
        ...
        docker run -it --rm \
            --gpus '"device='$GPU'"' \
            ...
            demo-cnn
        ...
        ```
